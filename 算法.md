# 算法

### 快速幂

计算底数为**a**，指数为**b**的幂对**c**取模的值。

~~~c
   long long fast_power(long long a, long long b, long long c) {
    long long ans = 1; //最终结果初始值为一
    a = a % c; //进循环之前先对a取一次模
    while(b) {
        if(b & 1) {
            ans = ans * a % c;
            //如果b是奇数，就直接乘到最终结果上并进行取模
        }
        a = a * a % c; //因为指数对半，底数就要直接乘方
        b = b / 2; //指数对半分减少计算量
    }
    return ans;
}
~~~

其中**b**可能有一些变式，核心是利用幂指数的性质进行同意化简，化简出的每一项都可以取模。

### 高精度计算

**int**和**long long**的数字位数是有限的，有时候会有非常大的数字，需要用到高精度计算。

首先是数字的输入，采用字符串数组输入然后统一转化成数字串数组的形式储存。

~~~c
int Input(int* x) {
	char s[1000000] = {0}; //字符串数组用来存储输入
	scanf("%s", s);
	int i = 0;
	while(s[i]) {
		i++;
	}
	//检测字符串数组有多少位
	for(int n = 1; n <= i; n++) {
		*(x + n) = *(s + i - n) - '0';
	}
	//将字符串数组从数字最低位开始逐位转换成数字并且换到对应的位的数字数组中
	return i; //为函数添加返回值，返回值为数字的位数，并且输入参数的数组下标就对应位数
}
~~~

~~~c
//加法计算
if(i1 >= i2) {
		i3 = i1 + 1;
	}
	else {
		i3 = i2 + 1;
	}
//判断两个数字哪个长，然后以长的那个数字再加一位作为和的位数
	for(int n = 1; n <= i3; n++) {
		c[n] = c[n] + a[n] + b[n];
		c[n + 1] = c[n] / 10;
		c[n] = c[n] % 10; 
	}
//每一位进行累加放到和的对应位上，考虑进位
	if(c[i3 + 1] == 0 && i3 > 0) i3--;
//如果之前多加的那一位为0那就去掉
	for(int n = i3; n >= 1; n--) {
		printf("%d",c[n]);
	}
//从高位开始往低位打印
~~~

~~~c
//减法运算（默认a数字大于b数字，否则在进行减法之前就要进行交换）
if(i1 >= i2) {
		i3 = i1;
	}
	else {
		i3 = i2;
	}
//差的位数可能是被减数位数或者减一
	for(int n = 1; n <= i3; n++) {
		if(a[n] >= b[n]) c[n] = c[n] + a[n] - b[n];
        //不需要借位
		else {
			c[n] = c[n] + a[n] - b[n] + 10;
			c[n + 1]--;
		}
        //需要借位
	}
	if(c[i3] == 0 && i3 > 0) i3--;
~~~

~~~c
//乘法运算
i3 = i1 + i2; //乘积的最高位数可能是两个乘数的位数相加
//如果是减一，在最后会进行判断
	for(int x = 1; x <= i1; x++) {
		for(int y = 1; y <= i2; y++) {
			c[x + y - 1] = c[x + y - 1] + a[x] * b[y];
			c[x + y] = c[x + y - 1] / 10 + c[x + y];
			c[x + y - 1] = c[x + y - 1] % 10;
		}
	}
//对两个数的每一位进行乘积并且存入到乘积数组中，考虑进位问题
	if(c[i3] == 0 && i3 > 0) i3--;
~~~

除数分为两种情况，一种是高精度另一种是低精度。

除数是低精度的时候直接模拟余数除法一位一位的计算，不需要将数组转置。

~~~c
long long x = 0, y;
	int i;
	int n = Input(a);
	scanf("%d", &y);
	for(i = 1; i <= n; i++) {
		res[i] = (x * 10 + a[i]) / y;
		x = (x * 10 + a[i]) % y;
	}
	i = 1;
	while(res[i] == 0) {
		i++;
	}
	while(i<=n) {
		
		printf("%d", res[i]);
		i++;
	}
	printf("余数为%d", x);
	return 0;
~~~

~~除数是高精度的时候，使用减法模拟除法，从被除数的最高位开始，一次一次减去除数的倍数。~~**（太难了暂时不学了）**

### 辗转相除法求公因数和公倍数

最基础的原理是辗转相除法，即a对b取余得到余数，然后将b和余数分别作为下一次辗转相除的a和b（这样的特性使得辗转相除法用递归很容易实现），直到余数为零，此时除数就是最大公因数。

~~~c
int gcd(int a, int b) {
    if(b == 0) return a;
    return gcd(b, a % b);
    //return b == 0 ? a : gcd(b, a % b); 
}
~~~

使用辗转相除法可以很容易求出最大公因数，用两个数除以最大公因数得到的商相乘，再乘上一个最大公因数，就是两个数的最小公倍数。

求多个数字的最大公因数，用辗转相除法求出任意两个数的最大公因数后，用这个最大公因数和其他的数字继续相除，最终得到的就是所有数字的最大公因数。

求多个数字的最小公倍数，将所有数字除以最大公因数，得到的所有的商相乘，再乘上一个最大公因数，就是所有数字的最小公倍数。

